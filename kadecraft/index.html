<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>KadeCraft Status</title>
<style>
  :root {
    color-scheme: light dark;
    --bg: #f5f7fa;
    --fg: #111;
    --card: #fff;
    --subtle: #666;
    --accent: #2563eb;
    --border: #e0e4ee;
  }
  @media (prefers-color-scheme: dark) {
    :root {
      --bg: #0f172a;
      --fg: #f1f5f9;
      --card: #1e293b;
      --subtle: #9ca3af;
      --accent: #3b82f6;
      --border: #334155;
    }
  }
  html,body { height: 100%; }
  body {
    margin: 0;
    font-family: system-ui, -apple-system, "Segoe UI", Roboto, Arial;
    background: var(--bg);
    color: var(--fg);
    display: flex;
    align-items: center;
    justify-content: center;
    padding: 20px;
    min-height: 100vh;
  }
  .card {
    background: var(--card);
    border-radius: 14px;
    padding: 20px;
    box-shadow: 0 8px 30px rgba(0,0,0,0.08);
    width: min(820px, 98%);
    transition: transform .18s ease;
  }
  .card.updating { transform: scale(1.01); }
  header { display: flex; gap: 12px; align-items: center; flex-wrap: wrap; }
  header img { width: 56px; height: 56px; border-radius: 8px; object-fit: cover; background:#ddd; }
  h1 { margin: 0; font-size: 1.2rem; }
  .meta { font-size: .95rem; margin-top: 4px; color: var(--subtle); }
  .status { margin-top: 6px; font-weight:700; }
  .online { color: #22c55e; }
  .offline { color: #ef4444; }
  .grid { display: grid; grid-template-columns: repeat(3,1fr); gap: 12px; margin-top: 12px; }
  .label { color: var(--subtle); font-size: .88rem; }
  .value { font-weight:700; }
  .players { margin-top: 14px; }
  .player-list { display:flex;flex-wrap:wrap;gap:8px;margin-top:10px; }
  .player { padding:6px 10px;border-radius:999px;border:1px solid var(--border); background:var(--bg); }
  .empty { color: var(--subtle); font-style: italic; }
  footer { margin-top: 14px; display:flex; justify-content:space-between; align-items:center; flex-wrap:wrap; color:var(--subtle); }
  button { background: var(--accent); color: #fff; border: 0; padding: 8px 12px; border-radius: 8px; cursor: pointer; font-weight:700; }
  @media (max-width:600px) { .grid { grid-template-columns: 1fr; } }
  /* small motd reset */
  #motd { margin-top: 6px; line-height: 1.1; }
</style>
</head>
<body>
  <div class="card" id="card" role="region" aria-label="KadeCraft server status">
    <header>
      <img id="favicon" alt="server icon">
      <div>
        <h1 id="serverName">KadeCraft</h1>
        <div id="motd" class="meta">Loading MOTD…</div>
        <div id="status" class="status">Checking…</div>
      </div>
    </header>

    <div class="grid" id="details" aria-hidden="false">
      <div><div class="label">Version</div><div class="value" id="version">—</div></div>
      <div><div class="label">Ping</div><div class="value" id="ping">— ms</div></div>
      <div><div class="label">Players</div><div class="value" id="count">—</div></div>
    </div>

    <div class="players" id="playersContainer">
      <div class="empty">Loading player list…</div>
    </div>

    <footer>
      <div id="lastUpdated">Last updated: —</div>
      <div>
        <button id="refresh">Refresh</button>
      </div>
    </footer>
  </div>

<script>
/* CONFIG */
const IP = "nl22.icehost.pl";
const PORT = 25732;
const INTERVAL_MS = 10000; // update every 10s

/* DOM */
const card = document.getElementById('card');
const faviconEl = document.getElementById('favicon');
const motdEl = document.getElementById('motd');
const statusEl = document.getElementById('status');
const versionEl = document.getElementById('version');
const pingEl = document.getElementById('ping');
const countEl = document.getElementById('count');
const playersContainer = document.getElementById('playersContainer');
const lastUpdated = document.getElementById('lastUpdated');
const refreshBtn = document.getElementById('refresh');

let intervalHandle = null;

/* helper: safe innerHTML assignment */
function setMotdHtml(html){
  // small safety: allow only basic tags returned by api.mcstatus (span, b, strong, i, br)
  // create a template, strip disallowed elements
  const tpl = document.createElement('template');
  tpl.innerHTML = html || "";
  const allowed = new Set(['SPAN','B','STRONG','I','EM','BR','U','SMALL']);
  function sanitize(node){
    const children = Array.from(node.childNodes);
    for(const child of children){
      if(child.nodeType === Node.ELEMENT_NODE){
        if(!allowed.has(child.nodeName)){
          // replace element with its text content (keeps text but removes tags)
          const text = document.createTextNode(child.textContent);
          node.replaceChild(text, child);
        } else {
          // keep element, but sanitize its children
          sanitize(child);
          // remove any attributes except style/class
          for(const attr of Array.from(child.attributes)){
            if(!['style','class'].includes(attr.name)) child.removeAttribute(attr.name);
          }
        }
      }
      // text nodes are fine
    }
  }
  sanitize(tpl.content);
  motdEl.innerHTML = tpl.innerHTML || "(no MOTD)";
}

/* fetch with no cache + measure client ping */
async function fetchStatus(noCache = false){
  card.classList.add('updating');
  try{
    // timestamp and headers to force fresh data
    const url = `https://api.mcstatus.io/v2/status/java/${encodeURIComponent(IP)}:${encodeURIComponent(PORT)}?t=${Date.now()}`;
    const t0 = performance.now();
    const res = await fetch(url, {
      method: 'GET',
      cache: 'no-store',
      headers: {
        'Cache-Control': 'no-cache, no-store, must-revalidate',
        'Pragma': 'no-cache'
      }
    });
    const duration = Math.round(performance.now() - t0);

    if(!res.ok) throw new Error('Network response ' + res.status);

    const data = await res.json();

    // favicon: use mcstatus.io icon endpoint (data URI or URL)
    faviconEl.src = `https://api.mcstatus.io/v2/icon/${IP}:${PORT}`;

    // MOTD: mcstatus returns html in data.motd.html (preferred)
    if(data.motd && data.motd.html){
      setMotdHtml(data.motd.html);
    } else if(data.motd && data.motd.clean){
      // array of lines
      setMotdHtml(data.motd.clean.map(l => `<span>${escapeHtml(l)}</span>`).join('<br>'));
    } else {
      motdEl.textContent = "(no MOTD)";
    }

    // status
    if(data.online){
      statusEl.textContent = "Online";
      statusEl.className = "status online";
    } else {
      statusEl.textContent = "Offline";
      statusEl.className = "status offline";
    }

    // version & ping
    versionEl.textContent = data.version?.name_clean || "Unknown";
    // prefer API latency if present, otherwise measured duration
    pingEl.textContent = (typeof data.latency === 'number' && data.latency >= 0) ? data.latency : duration;

    // players
    const online = data.players?.online ?? 0;
    const max = data.players?.max ?? '?';
    countEl.textContent = `${online}/${max}`;

    playersContainer.innerHTML = "";
    const list = data.players?.list;
    if(Array.isArray(list) && list.length > 0){
      const wrapper = document.createElement('div');
      wrapper.className = 'player-list';
      list.forEach(p => {
        const el = document.createElement('div');
        el.className = 'player';
        // mcstatus provides name_clean or name_raw
        el.textContent = p.name_clean || p.name || p.name_raw || p.raw || '(unknown)';
        wrapper.appendChild(el);
      });
      playersContainer.appendChild(wrapper);
    } else {
      playersContainer.innerHTML = '<div class="empty">No players online.</div>';
    }

    lastUpdated.textContent = "Last updated: " + new Date().toLocaleTimeString();
  }catch(err){
    console.error('Fetch error', err);
    statusEl.textContent = "Error";
    statusEl.className = "status offline";
    motdEl.textContent = "Error fetching server data.";
    playersContainer.innerHTML = `<div class="empty">${escapeHtml(err.message)}</div>`;
    pingEl.textContent = '—';
    lastUpdated.textContent = "Last updated: —";
  } finally {
    // remove updating state shortly after to keep visual feedback
    setTimeout(()=>card.classList.remove('updating'), 220);
  }
}

/* small helper to escape plain text when needed */
function escapeHtml(s){
  return String(s || '').replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;');
}

/* start auto-updating */
function startAutoUpdating(){
  if(intervalHandle) clearInterval(intervalHandle);
  intervalHandle = setInterval(()=>fetchStatus(false), INTERVAL_MS);
}

/* visibility change: refresh immediately when tab becomes visible */
document.addEventListener('visibilitychange', ()=> {
  if(!document.hidden){
    fetchStatus(true);
  }
});

/* manual refresh */
refreshBtn.addEventListener('click', ()=> fetchStatus(true));

/* initial load */
fetchStatus(true);
startAutoUpdating();

</script>
</body>
</html>
